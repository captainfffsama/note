#docker

上一章我们对 docker commit 进行了简单的剖析，相信大家对 commit 的使用场景有一定了解，今天再讲两个 docker 备份与恢复的常用命令。

那就是 export 和 save。

一个是导出镜像、一个是保存镜像，执行后的结果都一样——得到一个 tar 文件包。简单从字面上的描述，我们做一个区分：

commit：提交容器到镜像，实现容器持久化；

export：导出容器和镜像，实现容器内容持久化；

save：导出镜像文件，实现镜像内容持久化。

**第一，export 对当前的容器状态建立快照，并持久化为 tar 文件**

首先看下面这个镜像，镜像 ID 是

![](https://pic3.zhimg.com/v2-87e39c99185e022bdd54303d2217867e_b.png)

我们通过 inspect 命令看一下这个镜像的层文件

![](https://pic4.zhimg.com/v2-0eccffb60554c5a1a794c6b929ce01fb_b.jpg)

从上到下一共 17 层

现在我从这个镜像的实例化的容器里做一些事情，我新建一个 lxy 文件夹。

然后，通过 export 命令将这个容器持久化为 7b.tar

![](https://pic3.zhimg.com/v2-667c8da15c26b77332667e64228fd08e_b.png)

然后，通过 import 的方式，将这个导出的 tar 包镜像化

再来看这个镜像的层文件

![](https://pic4.zhimg.com/v2-62fffb2baacbfa840d73503712f8d71f_b.png)

发现这个镜像只剩了一层，其他的层级全没有了，整个镜像体积较之前也小了一些，一共是 436MB，之前是 452MB。

**第二，save 对当前的镜像进行持久化，形成 tar 文件**

还是这个镜像，我们使用 save 的方法持久化为 lxy.tar

然后，通过 load 的方式将这个导出的 tar 文件镜像化

再来看这个镜像的层文件

一点变化没有，同时，镜像大小是 452MB。

![](https://pic3.zhimg.com/v2-f1b3cb32444715366cc15687816886f6_b.jpg)

**第三，commit 把当前容器的内容新建一个层文件，覆盖在旧的镜像文件层之上**

还是这个镜像，这个容器，我们使用 commit 的方式进行提交，

![](https://pic3.zhimg.com/v2-ff372829ab76b7af63dd28c49762bf66_b.png)

然后查看这个镜像的层及文件

![](https://pic4.zhimg.com/v2-a53afdd604a0430c0bdfbc3c9f158503_b.jpg)

发现明显多了一层，也就是最下边这一层，尾数 1200。

这样分别有什么用武之地呢？

**第一，commit+save 模式：保留了一个镜像的所有历史文件和元数据，它把容器的内容作为一个新的层覆盖在原有镜像之上，然后实现持久化。原有的镜像没有改变。** 

这样的好处是，当我发现这个 commit+save 的镜像包有问题的时候，可以快速回滚到之前的镜像版本。

这波操作 666

你想，之前我们是怎么做产品版本管理的？每发一个版本就要生成一个安装部署包，久而久之版本越来越多，部署包的文件夹越来越大。部署实施人员在客户单位想回滚版本的时候可能只能够重新部署。

删除新版本 -->拷贝旧版本 -->安装旧版本…..

几个小时过去了。

有了 docker 这个回滚特性，那就直接回滚到镜像的某个层，然后再实例化一个容器就可以了。

几秒钟的工作量。

**第二，export 模式：打扫干净屋子再请客。把之前镜像的层级删干净，只保留最新的快照文件。** 

这种情况适用于我不需要回滚，当前的状态即是最佳状态的时候。这样做的好处是，删除了没有用处的历史数据，同时保留了镜像具有的所有功能，关键是镜像文件还小的很

一举三得。

怎么样，你搞清喜欢哪个了么？