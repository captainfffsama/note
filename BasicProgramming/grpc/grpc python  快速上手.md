#rpc
#protobuff

# grpc 安装
## protobuf 安装(Ubuntu)
```bash
sudo apt-get install autoconf automake libtool curl make g++ unzip

git clone https://github.com/protocolbuffers/protobuf.git
cd protobuf
git submodule update --init --recursive
./autogen.sh

 ./configure
 make
 make check
 sudo make install
 sudo ldconfig # refresh shared library cache.
```

 参考: https://github.com/protocolbuffers/protobuf/blob/master/src/README.md   
 
 ## python grpc安装
 ```bash
 pip install grpcio
 pip install grpcio-tools
 ```
 
 
 # 编写 rpc 服务
 ## 编写 protobuf
```proto
syntax="proto3";

package SoundAnalysis;

service SoundAnalysis {
    rpc JustTest (TestRequest) returns (TestReply) {}
}

message TestRequest {
    string hello=1;
}

message TestReply {
    string hi=1;
}
```
 
这里相当于构建了一个服务,客户端发送一个字符串请求 `TestRequest` 给服务端,服务端返回一个请求 `TestReply` 里面也是一个字符串.    
**注意:** proto 中服务返回语句的关键字是 returns 而非 return

## 生成代码
运行:
```bash
python -m grpc_tools.protoc -I ./  --python_out=. --grpc_python_out=. ./test.proto
```

这里在当前文件夹下会生成两个文件: `test_pb2.py` 和 `test_pb2_grpc.py` . 前者是原始 `protobuf` 协议生成的代码,而后者是插件生成的,特定的 grpc 代码.一般情况下后者代码中会导入前者代码,开发时,我们着重关注后者的代码.

```python
# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

import test_pb2 as test__pb2


class SoundAnalysisStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.JustTest = channel.unary_unary(
                '/SoundAnalysis.SoundAnalysis/JustTest',
                request_serializer=test__pb2.TestRequest.SerializeToString,
                response_deserializer=test__pb2.TestReply.FromString,
                )


class SoundAnalysisServicer(object):
    """Missing associated documentation comment in .proto file."""

    def JustTest(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_SoundAnalysisServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'JustTest': grpc.unary_unary_rpc_method_handler(
                    servicer.JustTest,
                    request_deserializer=test__pb2.TestRequest.FromString,
                    response_serializer=test__pb2.TestReply.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'SoundAnalysis.SoundAnalysis', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class SoundAnalysis(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def JustTest(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/SoundAnalysis.SoundAnalysis/JustTest',
            test__pb2.TestRequest.SerializeToString,
            test__pb2.TestReply.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

```

以上,我们主要关注以下三个类和方法:
- `SoundAnalysisStub` : 存根类.客户端用来链接 grpc 服务的.该类的构造函数中将使用 `grpc.Channel` 对象来初始化.对于服务中每个方法,在存根类进行初始化时,生成的代码都会给存根对象添加一个属性,名字就是服务中方法的名字.这个属性是一个可调用对象,根据 RPC 的类型,它会是 [UnaryUnaryMultiCallable](https://grpc.io/grpc/python/grpc.html?#grpc.UnaryUnaryMultiCallable), [UnaryStreamMultiCallable](https://grpc.io/grpc/python/grpc.html?#grpc.UnaryStreamMultiCallable), [StreamUnaryMultiCallable](https://grpc.io/grpc/python/grpc.html?#grpc.StreamUnaryMultiCallable), 或 [StreamStreamMultiCallable](https://grpc.io/grpc/python/grpc.html?#grpc.StreamStreamMultiCallable) 之一.

- `SoundAnalysisServicer`: 服务端用来链接 grpc 服务的.该类是服务端类的基类,对于服务中每个方法,在服务端类中都会有一个对应的函数.在实际开发服务类中,需要重载覆盖这些函数

- `add_SoundAnalysisServicer_to_server`: 使用 `grpc.Server` 来注册服务的.该函数将一个服务端对象的实现注册到 `grpc.Server` 对象.

参考: https://grpc.io/docs/languages/python/generated-code/

#  编写业务逻辑代码
## 服务端类业务逻辑代码
```python
import test_pb2
from test_pb2_grpc import  SoundAnalysisServicer, add_SoundAnalysisServicer_to_server

class SoundAnalysis(SoundAnalysisServicer):
    def JustTest(self, request, context):
        message=request.hello
        print("I get a message: {}".format(message))
        return  test_pb2.TestReply(hi="haha,get message")
```

这里显然是接收客户端发来的请求字符串并显示,然后发给客户端 `haha,get message`.   
然后我们继续添加注册服务和启动服务的代码:
```python
from concurrent import futures
import grpc

from test_pb2_grpc import add_SoundAnalysisServicer_to_server


def serve():
    server=grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    add_SoundAnalysisServicer_to_server(SoundAnalysis(),server)
    server.add_insecure_port('[::]:50051')
    server.start()
    server.wait_for_termination()

```


##  客户端代码
```python
import grpc

import test_pb2
import test_pb2_grpc as tbg


def run():
    # NOTE(gRPC Python Team): .close() is possible on a channel and should be
    # used in circumstances in which the with statement does not fit the needs
    # of the code.
    with grpc.insecure_channel('localhost:50051') as channel:
        stub = tbg.SoundAnalysisStub(channel)
        response = stub.JustTest(test_pb2.TestRequest(hello='you'))
    print("Greeter client received: " + response.hi)


if __name__ == '__main__':
    run()

```

分别执行客户端和服务端代码可得:
```bash
# server
I get a message: you 

# client
Greeter client received: haha,get message 
```

# 参考
- https://sunqi.site/posts/python-microservices-grpc-7/
