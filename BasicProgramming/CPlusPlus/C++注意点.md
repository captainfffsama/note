#CPP 

[TOC]

# 1. 对于浮点类型,不能使用 unsigned 或 signed 修饰符;浮点类型总是带符号的.
>C++17 入门经典P31

# 2. 浮点数值使用的常见错误原因
- 一些小数值没有准确转换为二进制浮点数值.在计算过程中,很容易把一些小错误放大为大错误.
- 计算两个非常接近的数值之差会丧失精度.若考虑两个浮点数值之差,而这两个数值仅在第6位数字上有区别,那么结果是只有一或两位是精确的,其他位可能出错.
- 处理范围相差几个数量级的数值会导致错误.比如,把两个存储为精度7位的 float 类型浮点数,但其中一个值相当于另一个值的 $10^8$ 倍,对他们执行相加操作.把较小值加到较大值上任意多次,较大值是不会有变化的.

>C++17 入门经典P33

# 3. 小心下溢
```cpp
unsigned int x {20u};
int y {30};
std::cout << x-y << std::endl;
```
输出不是 `-10` 而是 `4294967286`.这是因为 y 被转换成 unsigned int,以匹配 x 的类型.  
>C++17 入门经典 P37

# 4. 注意没有数学运算符或位运算符可用于比 int 更小的整数类型
注意操作数为 char 或 short,在进行数学运算或者位运算,总会首先被隐式转换为 int.
>C++17 入门经典 P47

# 5. 带符号按位移动
注意向右移位运算对带符号整数的操作随编译器和计算机架构不同而不同.在一些情况下,对负整数应用右移位运算符会在左边空出来的位上填充0.在其他情况下,符号位会扩充,在左边空出来的位上填充1.具体发生哪种情况,取决于编译器为负整数使用的二进制编码.
扩充符号位的原因是为了保持向右移位和除法运算的一致性.
**但应注意,总应该适应无符号整数来避免高阶位发生扩充**

>C++ 17 入门经典 P49

# 6. 关于全局变量
在所有代码块和类外部定义的变量就是全局变量. 注意和局部变量不同,在没有初始化时,全局变量默认是0,而局部变量是垃圾值.  
若在代码块中需要访问被覆盖的全局变量,就需要使用作用域解析运算符 `::`,比如同时有局部变量和全局变量 `value1`,想在全局变量被覆盖时使用全局变量,应使用`::value1`

# 7. 使用cctype 头文件提供的函数来处理字符
>C++17 入门经典 P66

# 8. switch 的使用范围
只能对整型值(int,long,unsigned short等),字符值(char等)和枚举类型值使用switch语句.  
case 值必须是编译时常量,且必须位移.
C++17 中,若需要使用贯穿行为,且不希望编译器提示警告,可以使用 `[[fallthrough]]` 语句.
>C++17 入门经典 P80

# 9. 关于 size_t 
size_t 并不是内置的基本类型,如 int,long 或 double;而是标准库定义的一个类型别名.更具体地说,它是某个不带符号的整数类型的别名,并且足够大,能容纳编译器支持的任何类型(包括数组).别名在 cstddef 头文件以及其他一些头文件中定义.但是,在实际应用中,大多数时候不需要使用 `#include` 来显示包含这些头文件,就能够使用 size_t 别名;通过包含其他更加高级的头文件(例如我们大部分示例使用的 iostream 头文件),常常就已经间接定义来这个别名.
> C++ 17入门经典 P29 S2.5

# 10. 关于浮点数加减
注意任何数字,只要其分数部分的分母是奇数,就不能准确地表示为二进制浮点数.
>C++17 入门经典 P92

# 11. 定义指针时,总是初始化它,若不能为其提供期望的值,就将其初始化为 [nullptr](C11/nullptr.md)
>C++ 17 入门经典 P122

# 12. [栈和自由存储区](内存分区.md)
自动变量在执行其定义时创建,在内存区域给自动变量分配的空间称为栈.栈有固定大小,有编译器确定.

操作系统和当前加载的其他程序未占用的那日存称为自由存储区.使用 new 运算符可以将自由存储区中的空间分配给任意类型的新变量.

["堆" ](内存分区.md#堆)常被用作是自由存储区同义词,但是一般是 `malloc`  和 `free` 操作的堆.

>C++ 17 入门经典 P134

# 13. 智能指针
有用的参考: <https://changkun.de/modern-cpp/zh-cn/05-pointers/>
- `std::unique_ptr<>`:一种独占的智能指针,它禁止其他智能指针与其共享同一个对象
- [`std::shared_ptr<>`](Scatter/shared_ptr.md):当有多个对象指向并(间接或并发)使用同一个对象,并且无法推断出何时全部使用完该共享对象时,使用这个智能指针
- `std::weak_ptr<>`:需要解决对象之间循环依赖时可用.在做对象缓存时也可能会用到,可以联系[python中的弱引用](../python/Python%20中弱引用的神奇用法与原理探析.md)


>C++ 17 入门经典 P140  P290

# 14. 引用
引用就是别名.一个常用的场景就是在基于范围的 for 循环中使用引用变量.
```cpp
double t[] {1,2,3,4,5};
for (auto& i:t)
{
    ...    
}
```
若不需修改,可以在前加上 `const`, 即: `for (const auto& i:t)`,这样可以避免每次在循环中复制对象.
>C++ 17 入门经典 P146

# 15. explicit
当对象的[构造函数](构造函数.md)中有的构造函数只包含一个实参(包括有多个参数,但其他参数都有默认值的构造函数),该构造函数可能会被用于隐式转换,为了防止这种隐蔽的错误,应在其声明的开头加上 `explicit` 关键字,来防止隐式转换.

# 16. 方法链
在类的成员方法中返回 `this` 指针或者是 `*this` 的引用,就可以实现在一个成员函数的调用后面接另一个成员函数调用,这种方法就是方法链.
>C++17 入门经典 P275


# 17. [类成员初始化方式](Scatter/类成员初始化方式.md)
1. 首选使用就地初始化和列表初始化
2. 成员变量初始化顺序由类定义中声明成员变量的顺序决定
3. **基类子对象，成员对象，引用，const成员必须放到成员初始化列表里面初始化**。普通int，double这种不是对象，不是引用，非const的东西，放到构造函数体里面赋值也没有问题。

>C++17 入门经典 P269

# 18. const 成员函数
当一个对象实例是 const 类型,那么就仅能调用它的 const 成员函数,即在成员函数形参之后加上 const 关键字的 成员函数,如下:
```cpp
class Box
{
	...
	double getLength() const {return length;}
}
```
该关键字会告诉编译器,`getLength`成员方法不会修改任何`Box`对象的成员变量.     

将成员方法指定为 `const`,实际上会使该成员函数内部的 `this` 指针成为 `const` 指针.  ^f94166
>C++17入门经典 P277

# 19. 忘掉 `const_cast<>()`

# 20. `mutable` 
当使用 `mutable` 来声明成员变量时,该成员变量可以被任何成员方法修改(包括 const 成员方法),其典型用途包括调试或日志记录,缓存和线程同步成员.但是通常很少使用.
>C++17入门经典 P279

# 21. 少用友元
声明友元破坏了面向对象编程的一个基石:数据隐藏.只有在绝对有必要时,才应该使用友元.
>C++17入门经典 P280

# 22. 单一定义规则(One Definition Rule,ODR)
>C++17入门经典 P231

# 23. 静态成员变量
1. 静态成员变量只于类本身有关,与类对象无关,它只定义一次,即使没有创建对象实例,静态成员变量也依然存在,并被所有的类对象共享.
2. 当静态成员变量定义为私有,那么外部就不能直接访问,需要通过成员函数或者静态成员函数来访问.
3. 静态成员变量不属于类对象,因此 [const 成员函数](#18%20const%20成员函数) 也可以修改非const的静态成员变量
4. 静态成员变量常常用于定义常量,比如定义一些公共常量来包含函数参数的边界值
5. **静态成员变量**可以和类具有相同类型,即 Box 类可以包含一个 Box 类型的静态成员变量, 但是注意,不能使用 `constexpr` 关键字来声明一个和类类型一样的静态常量.(参见 C++17入门经典 P287)
>C++17 入门经典 P283~P287

# 24. 静态成员函数
1. 静态成员函数[没有 `this` 指针,因此不能访问调用它的对象,也就不能声明为 const 函数](#^f94166).  
2. 静态成员函数对类的成员有完全访问权限,即私有成员它也可以访问
3. [静态成员函数可以在类外进行实现，此时不能加 static关键字](https://codeantenna.com/a/CGbI0RLmLa)
4. 
>C++17 入门经典  P288

# 25.  析构函数
1. 类只能有一个析构函数
2. 如果析构函数的函数体为空,最好使用`default`关键字,如下:
	```cpp
	Box::~Box()=default;
	```
3. 只有在释放类对象时需要执行一些操作的情况下,才需要定义类的析构函数.

>C++17 入门经典P288

# 26. 嵌套类
1. 将嵌套类在包含类中定义时,嵌套类的名称将被限定为包含类的作用域,并受到包含类的成员访问修饰符影响.
2. 嵌套类成员函数可以访问外层类对象的私有成员和静态成员,但必须通过类对象,类对象的指针或引用来访问.它在迭代器模式中有所使用,通过将迭代器类定义为 public 嵌套类,它可以允许外部代码遍历容器内容,而不必知晓数据结果的内部实现
3. 包含类不可以访问嵌套类的私有成员
>C++17 入门经典 P300

# 27. utility 头文件
![utility](标准库/utility.md)

# 28. 不能重载的运算符
- 条件运算符(?:)
- sizeof
大部分运算符都可以重载成成员函数或者非成员函数,少部分有限制.
**重载运算符本质上相当于一个普通函数**
>C++17入门经典 P311

# 29. 总应该根据 `op=()` 运算符来实现 `op()` 运算符

举个例子,应该使用 `operator+=()` 来实现 `operator+()` ,而非反过来.  
因为`operator+=()`通常是一个原地操作,直接返回左操作数的引用或者this指针. `operator+()` 则通常会创建一个左操作数的副本.若使用 `operator+()` 来实现`operator+=()`,则会在`operator+=()`中创建一个临时副本,造成性能损失.

>C++17入门经典 P318

# 30. 二元运算符优先使用成员函数实现
二元运算符通常可以使用,成员函数,非成员函数,友元函数来实现.**应当优先选择使用成员函数来实现!**,但在以下两种情况例外:
- 在某些场景中,除来实现非成员函数,没有其他选择,即使这意味着要把运算符重载为友元函数.比如重载的二元运算符的第一个实参是基本类型或是与当前正在编写的类不同的类型.
- **更加常见的是**,当希望二元运算符的左操作数可被隐式转换时,可能首选将运算符重载实现为非成员函数而不是成员函数.
**注意:** 当某个运算符的重载实现为非成员函数时,该运算符的其他所有重载也应实现为非成员函数,保持风格上的一致.

>C++17入门经典 P319

# 31. `std::rel_ops`名称空间中的运算符模板不允许隐式转换

# 32. 递增递减运算符重载都需要两个函数
递增递减运算符重载都需要两个函数:一个运算符放在操作数之前调用,一个则是放在操作数之后调用.前缀和后缀的形式通过一个int类型的假参数来进行区分.  

递增递减运算符前缀形式总应该返回对当前对象(已经递增或递减)的引用,而后缀形式总应返回源对象在被递增或者递减之前的一个副本.
>C++17入门经典 P321

# 33. 对于链表等随机访问性能很差的数据结构,不应重载下标运算符

# 34. 函数对象
不同于大部分运算符,函数调用运算符必须被重载为成员函数.不能把它们定义为普通函数.函数调用运算符也是唯一不限制参数个数且能够有默认实参的运算符.

>C++17入门经典P326

# 35. 类型转换运算符
类型转换运算符也必须被重载为成员函数,而不能定义为普通函数.  

**注意:** 构造函数也可以实现转换,因此当编译器进行隐式转换时,可能会不知道该使用那个构造函数.这时可以把一个成员或这两个成员都声明为 `explicit`

>C++17入门经典P326


# 36. 拷贝构造函数
**[拷贝构造函数](构造函数#拷贝构造函数)的参数必须是以引用传递的,否则拷贝构造函数将不断调用自己直到耗尽内存.  引用务必使用 const 引用**


# 37. 赋值运算符
编译器会提供默认的复制赋值运算符,它会简单的逐个复制类的所有成员变量(采用它们在类定义中的声明顺序).

对于一些自身管理动态分配的内存的类,默认赋值运算符是不合适的.比如一个类A1中包含类一个成员是一个指针,默认赋值运算符在赋值类A2中对应成员时,会将成员指针指向和类A1中指针相同的地址,那么在类A1析构之后,类A2包含的就是一个垃圾值.

赋值运算符不能定义为普通函数,它是唯一的必须作为类成员函数重载的二元运算符.

用户定义每个复制赋值运算符应该首先检查自我赋值的情况.忘记检查自我赋值,可能在不小心将对象赋值给自身时发生致命错误.

任何赋值运算符都应该返回对`*this`的引用
>C++17入门经典P328

# 38. 何时重载拷贝构造函数和复制赋值运算符
当类管理的成员有指向自由存储区内存的指针,则不能不加修改地使用副本构造函数和复制赋值运算符;如果有原指针成员,就必须定义析构函数.
>C++17入门经典P330

# 39. 派生类成员的访问级别
即在继承时指定如何继承.派生类成员的权限的上限.

在多数情况下,使用 public 继承,然后将基类成员变量声明成private或者 protected. 这样基类子对象就是派生类对象的内部对象,而基类的接口依然由派生类继承
>C++17入门经典P338

# 40. 对于类,总应该将成员变量声明成 private
注意这点和python理念的不同

# 41. 改变继承成员的访问修饰符
在继承类中使用 `using 基类名::成员名;`的方式可以在继承类中使用基类成员了,同时改成员在继承类中访问级别受其在继承类中访问修饰符的影响.

举例: 假设 Son 类私有继承 Basic 类, Basic类中有一个 protected 成员方法 A.  现在希望A方法在 Son 中是 public 那么就可以使用:
```cpp
class Son : private Basic
{
public:
	using Basic::A;
}
```

注意这种声明不能应用于基类私有成员,因为私有成员在派生类中不能访问.但它可以将基类中的protected 成员改成 public 成员.

感觉没啥用,直接在子类中覆盖父类成员不就行了?

>C++17入门经典 P340

# 42. string_view
![使用准则1](C17/string_view.md#^c2f1b9)


# 43. 类的构造顺序
基类对象在派生类对象之前被实例化.  
假设 Son 继承 Basic 类,先调用Basic的构造函数构建Son继承到的Basic的部分,此时Son中派生的部分是未被初始化的状态,然后再调用Son的构造函数,初始化剩下的部分.  
**注意基类的成员变量是不能在派生类的构造函数的初始化列表中初始化的!只能在子类的构造函数函数体中初始化!**

>21天学通C++ P198
>C++ primer p556

# 44. 若子类构造时涉及继承自父类的成员变量,须在子类构造函数成员初始化列表中显式的将有关成员变量传给父类构造函数
由于子类中继承来的成员变量依然由父类管理,因此在使用子类的副本构造函数时,还是需要在子类拷贝构造函数中显式调用父类的拷贝构造函数.否则编译器将调用父类的默认构造函数来构建父类管理的成员变量
.

>C++17入门经典 P342
>[C++日志（三十一）类继承时的构造函数 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/106920426)

# 45. 类不能继承默认,拷贝和移动构造函数,析构函数,赋值运算符
><https://www.zhihu.com/question/26162745/answer/32288264>

# 46. 多继承情况下,若名称冲突,使用 `using` 来显示指明使用哪个基类的成员
>C++17入门经典P352

# 47. 使用虚基类可以避免在菱形继承中重复继承基类
例如:
```cpp
class Contents : public virtual Common
{
...
};
```

>C++17入门经典P353

# 48. 派生类对象总包含每个基类完整的子对象,但是每个基类仅表示派生类对象的一部分

# 49. 使用对象调用虚函数是静态解析,只有通过指针或引用调用虚函数,才是动态解析.
使用对象调用虚函数是静态解析,只有通过指针或引用调用虚函数,才是动态解析. 
若函数定义在类定义外部(在对应的CPP中),那么就不能在函数定义中添加 `virtual`

>C++17入门经典 P359

# 50. 子类虚函数限制
1. 子类和基类的虚[函数签名](Scatter/函数签名.md)必须一样
2. 一般子类和基类虚函数的返回值也必须一样,但是若基类返回类型是类类型的指针或者引用除外,此时子类可以返回更特殊的子类类型的指针或引用.这个技术术语叫"[协变性](Scatter/协变性.md)"
3. 虚函数不可以是模板函数
>C++17入门经典 P361

# 51. 静态成员函数不能使用 `virtual`  

# 52. 在虚函数重写声明中总应该添加 `override` 限定符
在虚函数重写声明中总应该添加 [`override`](Scatter/override.md) 限定符,这样可以保证编写虚函数重写时函数签名没有写错,同时当父类虚函数签名发生改变时,也可以提醒开发者需要同步修改子类中虚函数的重写.

# 53. 虚函数与访问修饰符
**访问修饰符只是影响虚函数的调用,但不影响虚函数的重写.** 推荐将虚函数声明为私有.
>C++17入门经典 P364

# 54. 虚函数默认实参值
默认实参值是在编译期间处理,因此若父类声明中带有默认实参值,那么通过基类指针调用该函数是,就总是从函数基类版本中接受默认实参值.而该函数在派生类中的默认实参值不起作用.

**注意该点是反直觉的**
>C++17入门经典 P365  

# 55. 重写,重载和隐藏
**重载函数必须在同一作用域中定义,而父类和子类的作用域是不同的.** 因此当子类和父类函数同名,但是签名不同,不叫 **重载** ,而是子类对父类方法的 **覆盖和隐藏** .  

而子类和父类的函数签名一样,叫做子类对父类方法的 **重写**,常用于多态.
>C++17入门经典 P361

# 56. 虚析构函数
1. 当一个类至少有一个虚成员函数时,就必须使其析构函数称为虚析构函数.仅当非虚析构函数不是public时,可以不遵守此指导原则.
2. 编译器生成析构函数不是虚析构函数,除非显式把它们声明成虚析构函数,因此推荐使用`default`关键字来显示指明.
	```cpp
	virtual ~Son() = defaultlv;
	```

>C++17入门经典 P369

# 57. 构造函数和析构函数中虚函数的调用都是静态解析
>C++17入门经典 P375

