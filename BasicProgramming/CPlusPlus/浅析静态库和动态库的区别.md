#CPP 

[toc]

([浅析静态库和动态库的区别_牛客博客 (nowcoder.net)](https://blog.nowcoder.net/n/8e07e78a703c413c916d0f830b8ceda7))

# 什么是库

库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。

本质上来说库是一种可执行代码的二进制形式，可以\*\*\*作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。

所谓静态、动态是指链接。回顾一下，将一个程序编译成可执行程序的步骤：  
![](https://uploadfiles.nowcoder.com/images/20200113/860432_1578913126076_00F51FD75453B2462E4D7B530E12A64D)

# 静态库
之所以成为【静态库】，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。

试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：

1.  静态库对函数库的链接是放在编译时期完成的。
2.  程序在运行时与函数库再无瓜葛，移植方便。
3.  浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。

    Linux下使用ar工具、Windows下vs使用lib.exe，将目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索。一般创建静态库的步骤如图所示：  
    ![](https://uploadfiles.nowcoder.com/images/20200113/860432_1578913126166_8A2F7B1C26BE42E9191ABD9EEF33BDAE)
    
# 动态库
为什么需要动态库，其实也是静态库的特点导致。

*   空间浪费是静态库的一个问题。

![](https://uploadfiles.nowcoder.com/images/20200113/860432_1578913126313_312058C426B0FF7FE3F50F3612DC01ED)

*   另一个问题是静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，全量更新）。

动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。  
![](https://uploadfiles.nowcoder.com/images/20200113/860432_1578913126754_CC295DD21EAB35889B77495715957914)
  
动态库特点总结：

1.  动态库把对一些库函数的链接载入推迟到程序运行的时期。
2.  可以实现进程之间的资源共享。（因此动态库也称为共享）
3.  将一些程序升级变得简单。    
4.  甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）。

Window与Linux执行文件格式不同，在创建动态库的时候有一些差异。

*   在Windows系统下的执行文件格式是PE格式，动态库需要一个DllMain函数做出初始化的入口，通常在导出函数的声明时需要有\_declspec(dllexport)关键字。
*   Linux下gcc编译的执行文件默认是ELF格式，不需要初始化入口，亦不需要函数做特别的声明，编写比较方便。

与创建静态库不同的是，不需要打包工具（ar、lib.exe），直接使用编译器即可创建动态库。

# 区别于联系
二者的不同点在于代码被载入的时刻不同。  
静态库的代码在编译过程中已经被载入可执行程序,因此体积比较大。  
动态库(共享库)的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，因此代码体积比较小。  
不同的应用程序如果调用相同的库,那么在内存中只需要有一份该动态库(共享库)的实例。  
静态库和动态库的最大区别,静态情况下,把库直接加载到程序中,而动态库链接的时候,它只是保留接口,将动态库与程序代码独立,这样就可以提高代码的可复用度，和降低程序的耦合度。  
静态库在程序**编译**时会被连接到目标代码中，程序运行时将不再需要该静态库。  
动态库在程序编译时并不会被连接到目标代码中，而是在程序**运行**是才被载入，因此在程序运行时还需要动态库存在